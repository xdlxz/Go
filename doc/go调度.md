
Go 语言的调度器从 Go 1.14 版本开始支持**抢占式调度**。
在此之前，Go 的调度机制主要依赖于**协作式调度**

# 抢占式调度的背景

在 Go 1.14 之前，Go 使用的是协作式调度，这意味着 Goroutine（Go 的轻量级线程）必须自行主动放弃 CPU 使用权，才能让其他 Goroutine 有机会运行。
协作式调度的机制依赖于 Goroutine 在特定的点（如函数调用、I/O 操作等）自动让出控制权。
这种方式在大多数情况下工作良好，但如果一个 Goroutine 运行了大量的计算密集型任务而没有执行任何函数调用或 I/O 操作，
调度器就无法及时将其调度出去，导致其他 Goroutine 可能被阻塞，系统的响应能力降低。
为了解决这个问题，Go 在 1.14 版本引入了抢占式调度，使得即使 Goroutine 没有主动让出 CPU，
调度器也可以在合适的时机强制调度出当前 Goroutine。

# 抢占式调度的工作原理
  ### 1.周期性检查：
Go 运行时会在 Goroutine 执行的过程中定期检查是否有必要进行调度。
这个检查点是在 Goroutine 执行栈增长或函数调用时进行的。
如果发现当前 Goroutine 占用了过多的时间，它就会被抢占，调度器会将其他 Goroutine 调度进来。
 ### 2.基于系统时钟的计时：
Go调度器会在后台启动一个计时器，在每个线程上定期产生中断信号。
这个信号会被Go运行时捕获，用来检查当前 Goroutine 的运行时间是否过长。
如果是，它会触发抢占，使得其他 Goroutine 有机会运行。
 ### 3.编译器插入检查点：
在一些计算密集型的代码路径中，编译器会自动插入抢占检查点（如循环中的某些位置）。
如果 Goroutine 长时间占用 CPU，这些检查点会检测到并强制 Goroutine 让出控制权。

# 抢占式调度的优势
	- 提高系统响应性：抢占式调度解决了计算密集型 Goroutine 长时间占用 CPU 的问题，使得其他 Goroutine 仍然可以被及时调度，提升了系统的整体响应能力。
	- 避免长时间阻塞：即使某些 Goroutine 没有主动放弃 CPU，调度器也能够强制抢占，避免出现长时间阻塞的情况。
